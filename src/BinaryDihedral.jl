"""
Binary Dihedral (Dicyclic) Group Module

Implements the binary dihedral group Dic_n as a subgroup of unit quaternions (Spin(3)/SU(2)),
which is the 2-to-1 lift of the dihedral group D_n under the double cover SU(2) → SO(3).

Mathematical background:
- D_n: dihedral group with 2n elements, generated by rotation r (order n) and reflection s
- Dic_n: dicyclic group with 4n elements, generated by a (order 2n) and b (order 4)
- Relations: a^{2n} = 1, b² = a^n, bab⁻¹ = a⁻¹
- Projection: {±q} in Dic_n maps to single element in D_n

Reference: Conway & Smith, "On Quaternions and Octonions" (2003), Chapter 3.
"""
module BinaryDihedral

using Rotations
using LinearAlgebra

export
    DicyclicGroup, dicyclic_element, project_to_dihedral,
    dihedral_to_dicyclic, compose_dicyclic,
    encode_operator_chain, decode_operator_chain,
    chain_length_dicyclic, chain_length_dihedral,
    test_double_cover

"""
    DicyclicGroup

Represents the dicyclic group Dic_n embedded in unit quaternions.
"""
struct DicyclicGroup
    n::Int  # Order of rotation subgroup in D_n (D_n has 2n elements, Dic_n has 4n)
end

"""
    dicyclic_generator_a(g::DicyclicGroup) -> QuatRotation

Generator a = exp(πi/n) in quaternion form: (cos(π/n), sin(π/n), 0, 0)
Order 2n in Dic_n.
"""
function dicyclic_generator_a(g::DicyclicGroup)
    θ = π / g.n
    return QuatRotation(cos(θ), sin(θ), 0.0, 0.0)
end

"""
    dicyclic_generator_b(g::DicyclicGroup) -> QuatRotation

Generator b = j in quaternion form: (0, 0, 1, 0)
Satisfies b² = a^n = -1.
"""
function dicyclic_generator_b(g::DicyclicGroup)
    return QuatRotation(0.0, 0.0, 1.0, 0.0)
end

"""
    dicyclic_element(g::DicyclicGroup, k::Int, use_b::Bool) -> QuatRotation

Compute the dicyclic element a^k or b·a^k.
k should be in range 0:(2n-1).
"""
function dicyclic_element(g::DicyclicGroup, k::Int, use_b::Bool)
    a = dicyclic_generator_a(g)
    b = dicyclic_generator_b(g)

    # Compute a^k
    k = mod(k, 2 * g.n)
    θ = k * π / g.n
    a_k = QuatRotation(cos(θ), sin(θ), 0.0, 0.0)

    if use_b
        # b·a^k via quaternion multiplication
        return b * a_k
    else
        return a_k
    end
end

"""
    all_elements(g::DicyclicGroup) -> Vector{QuatRotation}

Generate all 4n elements of the dicyclic group.
"""
function all_elements(g::DicyclicGroup)
    elements = QuatRotation[]
    for k in 0:(2*g.n - 1)
        push!(elements, dicyclic_element(g, k, false))  # a^k
        push!(elements, dicyclic_element(g, k, true))   # b·a^k
    end
    return elements
end

"""
    project_to_dihedral(q::QuatRotation, g::DicyclicGroup) -> Tuple{Int, Bool}

Project a dicyclic element to dihedral group D_n.
Returns (k, is_reflection) where the dihedral element is r^k (rotation) or s·r^k (reflection).
The projection identifies q ≈ -q.
"""
function project_to_dihedral(q::QuatRotation, g::DicyclicGroup)
    # Normalize to handle ±q equivalence: prefer positive w component
    w, x, y, z = q.q.s, q.q.v1, q.q.v2, q.q.v3

    if w < 0
        w, x, y, z = -w, -x, -y, -z
    end

    # Check if this is a "pure rotation" (a^k type) or "reflection" (b·a^k type)
    # Pure rotations have form (cos θ, sin θ, 0, 0) up to sign
    # Reflections have form (0, 0, y, z) or similar with small w,x

    if abs(y) < 1e-10 && abs(z) < 1e-10
        # Pure rotation type: a^k
        θ = atan(x, w)  # atan2(sin θ, cos θ) = θ
        k = round(Int, θ * g.n / π)
        k = mod(k, g.n)
        return (k, false)
    else
        # Reflection type: b·a^k
        # b·a^k = (0, 0, cos(kπ/n), sin(kπ/n)) when a = exp(iπ/n), b = j
        # Actually: b·a^k where b=(0,0,1,0), a^k=(cos θ, sin θ, 0, 0)
        # gives (0, 0, cos θ, -sin θ) by quaternion multiplication
        θ = atan(-z, y)
        k = round(Int, θ * g.n / π)
        k = mod(k, g.n)
        return (k, true)
    end
end

"""
    dihedral_to_dicyclic(k::Int, is_reflection::Bool, g::DicyclicGroup) -> QuatRotation

Lift a dihedral element to dicyclic group (canonical choice from the 2 preimages).
Chooses the representative with positive scalar part when possible.
"""
function dihedral_to_dicyclic(k::Int, is_reflection::Bool, g::DicyclicGroup)
    q = dicyclic_element(g, k, is_reflection)

    # Canonicalize: prefer positive w
    if q.q.s < 0
        q = QuatRotation(-q.q.s, -q.q.v1, -q.q.v2, -q.q.v3)
    end

    return q
end

"""
    compose_dicyclic(q1::QuatRotation, q2::QuatRotation) -> QuatRotation

Compose two dicyclic elements via quaternion multiplication.
"""
function compose_dicyclic(q1::QuatRotation, q2::QuatRotation)
    return q1 * q2
end

"""
    test_double_cover(g::DicyclicGroup) -> Bool

Verify the 2-to-1 property: for each dicyclic element q, both q and -q project
to the same dihedral element.
"""
function test_double_cover(g::DicyclicGroup)
    for q in all_elements(g)
        neg_q = QuatRotation(-q.q.s, -q.q.v1, -q.q.v2, -q.q.v3)

        proj_q = project_to_dihedral(q, g)
        proj_neg_q = project_to_dihedral(neg_q, g)

        if proj_q != proj_neg_q
            return false
        end
    end
    return true
end

# =============================================================================
# Operator Chain Encoding
# =============================================================================

"""
Map genomic dihedral operators to (k, is_reflection) pairs.
For DNA of length n, we have D_n group.
"""
const DIHEDRAL_OPS = Dict(
    :id => (0, false),
    :S => (1, false),      # Shift by 1 = rotation
    :R => (0, true),       # Reverse = reflection
    :K => :special,        # Complement is not in D_n, handle separately
    :RC => :special        # RC = complement ∘ reverse
)

"""
    encode_operator_chain(ops::Vector{Symbol}, n::Int) -> Vector{QuatRotation}

Encode a chain of dihedral operators as dicyclic quaternions.
Only handles pure dihedral operators (S, R, id); K and RC are flagged.

Returns the sequence of quaternion states representing the chain.
"""
function encode_operator_chain(ops::Vector{Symbol}, n::Int)
    g = DicyclicGroup(n)
    states = QuatRotation[]

    # Start at identity
    current = QuatRotation(1.0, 0.0, 0.0, 0.0)
    push!(states, current)

    for op in ops
        if op == :id
            # No change
        elseif op == :S
            # Shift = rotation by 2π/n in the dihedral sense
            # In dicyclic: a corresponds to half-rotation, so S corresponds to a²
            q_op = dicyclic_element(g, 2, false)
            current = compose_dicyclic(current, q_op)
        elseif op == :R
            # Reverse = reflection
            q_op = dicyclic_element(g, 0, true)
            current = compose_dicyclic(current, q_op)
        else
            # Non-dihedral operator, skip or mark
            continue
        end
        push!(states, current)
    end

    return states
end

"""
    chain_length_dicyclic(ops::Vector{Symbol}, n::Int) -> Int

Compute the minimal number of generators needed to express the composition
in the dicyclic representation.
"""
function chain_length_dicyclic(ops::Vector{Symbol}, n::Int)
    states = encode_operator_chain(ops, n)
    if isempty(states)
        return 0
    end

    final_state = states[end]
    g = DicyclicGroup(n)
    k, is_ref = project_to_dihedral(final_state, g)

    # Minimal representation: rotation by k needs log(k) or just k generators
    # For reflection: 1 generator + rotation
    if is_ref
        return k + 1
    else
        return k
    end
end

"""
    chain_length_dihedral(ops::Vector{Symbol}, n::Int) -> Int

Compute the reduced length in dihedral group (not dicyclic).
"""
function chain_length_dihedral(ops::Vector{Symbol}, n::Int)
    # Compose all operators in D_n
    total_rotation = 0
    is_reflected = false

    for op in ops
        if op == :S
            if is_reflected
                total_rotation = mod(total_rotation - 1, n)
            else
                total_rotation = mod(total_rotation + 1, n)
            end
        elseif op == :R
            is_reflected = !is_reflected
        end
    end

    # Minimal length = rotation amount + (1 if reflected)
    if is_reflected
        return total_rotation + 1
    else
        return total_rotation
    end
end

end # module
